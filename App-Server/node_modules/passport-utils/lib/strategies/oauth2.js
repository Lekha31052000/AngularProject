/**
 * Module dependencies.
 */
var strategy = require('./strategy'),
    util = require('util'),
    helper = require('../utils/helper'),
    querystring = require('querystring'),
    request = require('request'),
    InternalOAuthError = require('../errors/internaloautherror');

/**
 * `OAuth2Strategy` constructor.
 *
 * The OAuth 2.0 authentication strategy authenticates requests using the OAuth
 * 2.0 protocol.
 *
 * OAuth 2.0 provides a facility for delegated authentication, whereby users can
 * authenticate using a third-party service such as Facebook.  Delegating in
 * this manner involves a sequence of events, including redirecting the user to
 * the third-party service for authorization.  Once authorization has been
 * granted, the user is redirected back to the application and an authorization
 * code can be used to obtain credentials.
 *
 * Applications must supply a callback which accepts an `accessToken`,
 * `refreshToken` and service-specific `profile`, and then calls the `done`
 * callback supplying a `user`, which should be set to `false` if the
 * credentials are not valid.  If an exception occured, `err` should be set.
 *
 * Options:
 *   - `authorizationURL`  URL used to obtain an authorization grant
 *   - `tokenURL`          URL used to obtain an access token
 *   - `clientID`          identifies client to service provider
 *   - `clientSecret`      secret used to establish ownership of the client identifer
 *   - `callbackURL`       URL to which the service provider will redirect the user after obtaining authorization
 *   - `passReqToCallback` when `true`, `req` is the first argument to the verify callback (default: `false`)
 *
 * Examples:
 *
 *     passport.use(new OAuth2Strategy({
 *         authorizationURL: 'https://www.example.com/oauth2/authorize',
 *         tokenURL: 'https://www.example.com/oauth2/token',
 *         clientID: '123-456-789',
 *         clientSecret: 'shhh-its-a-secret'
 *         callbackURL: 'https://www.example.net/auth/example/callback'
 *       },
 *       function(accessToken, refreshToken, profile, done) {
 *         User.findOrCreate(..., function (err, user) {
 *           done(err, user);
 *         });
 *       }
 *     ));
 *
 * @param {Object} options
 * @param {Function} callback
 * @api public
 */
function OAuth2Strategy(options, verify){
    strategy.call(this);
    options = options || {};

    if (!options.authorizeUrl){
        throw new Error('OAuth2Strategy requires a authorizationURL option');
    }
    if (!options.accessTokenUrl){
        throw new Error('OAuthStrategy requires a tokenURL option');
    }
    if (!options.clientID){
        throw new Error('OAuth2Strategy requires a clientID option');
    }
    if (!options.clientSecret){
        throw new Error('OAuth2Strategy requires a clientSecret option');
    }

    this.name = 'oauth2';
    this._clientID = options.clientID;
    this._clientSecret = options.clientSecret;
    this._authorizeUrl = options.authorizeUrl;
    this._accessTokenUrl = options.accessTokenUrl;
    //authentication base site.
    this._baseSite= options.baseSite || '';
    //authenticated callback function
    this._verify = verify;
    this._scope = options.scope;
    this._scopeSeparator = options.scopeSeparator || ' ';
    this._passReqToCallback = options.passReqToCallback;
    this._callbackURL = options.callbackURL || '';
}
util.inherits(OAuth2Strategy, strategy);
/**
 * Authenticate request by delegating to a service provider using OAuth 2.0.
 *
 * @param {Object} req
 * @param {Object} options
 * @api protected
 */
OAuth2Strategy.prototype.authenticate = function(req, options){
    var self = this;
    if (req.query && req.query.error){
        // TODO: Error information pertaining to OAuth 2.0 flows is encoded in the
        // query parameters, and should be propagated to the application.
        return this.fail();
    }
    if(options && options.callbackURL){
        options.callbackURL = helper.resolvePathToURI(req, options.callbackURL);
    }else{
        options.callbackURL = helper.resolvePathToURI(req, this._callbackURL);
    }
    //has authorize code.
    if(req.query && req.query.code){
        this.getOAuthAccessToken({
            grant_type: 'authorization_code',
            code: req.query.code
        },function(err, access_token, refresh_token, result){
            if(err){
                self.error(new InternalOAuthError('failed to obtain access token', err));
            }
            //start to load user profile
            self.loadUserProfile(accessToken, function(){
                if(err){
                    return self.error(err);
                }
                /**
                 * verified user information callback
                 * @param err error object
                 * @param user user object
                 * @param info info object
                 * @returns {*}
                 */
                function verified(err, user, info){
                    if(err){
                        return self.error(err);
                    }
                    if(!user){
                        return self.fail(info);
                    }
                    self.success(user, info);
                }
                if(self._passReqToCallback){
                    switch(self._verify.length){

                    }
                }else{

                }
            });
        });
    }else{
        //redirect to service provider.
        var params = this.generateAuthorizationParams(options);
        this.redirect(this.generateAuthorizeUrl(params));
    }
};
/**
 * get oauth access token
 * @param {String} code
 * @param {Object} params
 * @param {Function} callback
 */
OAuth2Strategy.prototype.getOAuthAccessToken = function(options, callback){
    var params = this.generateAccessTokenParams(options);
    request.post({
        url:this.getAccessTokenUrl(),
        form:params
    },function(err,httpResponse,body){
        if(err){
            callback(err);
        }else{
            var result;
            try{
                // As of http://tools.ietf.org/html/draft-ietf-oauth-v2-07
                // responses should be in JSON
                result = JSON.parse(body);
            }catch(e){
                // .... However both Facebook + Github currently use rev05 of the spec
                // and neither seem to specify a content-type correctly in their response headers :(
                // clients of these services will suffer a *minor* performance cost of the exception
                // being thrown
                result = querystring.parse(body);
            }
            var access_token = result["access_token"];
            var refresh_token = result["refresh_token"];
            //execute callback.
            switch(callback.length){
                case 2:
                    callback(null, result);
                    break;
                case 3:
                    callback(null, access_token, refresh_token);
                    break;
                default:
                    callback(null, access_token, refresh_token, result);
            }
        }
    });
};
/**
 * get access token url.
 */
OAuth2Strategy.prototype.getAccessTokenUrl = function(){
    return this._baseSite + this._accessTokenUrl;
};
/**
 * generate authorize url
 * @param params
 */
OAuth2Strategy.prototype.generateAuthorizeUrl = function(params){
    params = params || {};
    params['client_id'] = this._clientID;
    return this._baseSite + this._authorizeUrl + "?" + querystring.stringify(params);
}
/**
 * generate access token parameters
 * @param {Object} params
 */
OAuth2Strategy.prototype.generateAccessTokenParams = function(options){
    var params = {
        client_id: this._clientID,
        client_secret: this._clientSecret,
        grant_type: options.grant_type
    };
    var codeParam = (options.grant_type === 'refresh_token') ? 'refresh_token' : 'code';
    params[codeParam]= options.code;
    return params;
};
/**
 * Return parameters to be included in the authorization request.
 *
 * Some OAuth 2.0 providers allow additional, non-standard parameters to be
 * included when requesting authorization.  Since these parameters are not
 * standardized by the OAuth 2.0 specification, OAuth 2.0-based authentication
 * strategies can overwrite this function in order to populate these parameters
 * as required by the provider.
 *
 * @param {Object} options
 * @return {Object}
 * @api protected
 */
OAuth2Strategy.prototype.generateAuthorizationParams = function(options) {
    options = options || {};
    var params = {
        'response_type': 'code',
        'redirect_uri': options.callbackURL
    };
    var scope = options.scope || this._scope;
    var scopeSeparator = options.scopeSeparator || this._scopeSeparator;
    if (scope) {
        if (Array.isArray(scope)){
            scope = scope.join(scopeSeparator);
        }
        params.scope = scope;
    }
    if (options.state){
        params.state = state;
    }
    return params;
};
/**
 * load user profile by access token, needed to be implement in subclass.
 * @param {String} accessToken
 * @param {Function} done
 */
OAuth2Strategy.prototype.loadUserProfile = function(accessToken, done){
    return done(null);
};

/**
 * Expose `OAuth2Strategy`.
 */
module.exports = OAuth2Strategy;
